<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 3D 互動情緒粒子系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入 OrbitControls 用於滑鼠互動 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        
        /* 側邊欄控制面板 */
        .control-panel-container {
            position: absolute;
            top: 0;
            left: 0;
            height: 100vh;
            display: flex;
            z-index: 100;
            transition: transform 0.3s ease;
        }
        
        .control-panel-container.collapsed {
            transform: translateX(-320px);
        }

        .sidebar {
            width: 320px;
            height: 100%;
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(15px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            box-shadow: 10px 0 30px rgba(0,0,0,0.5);
            overflow-y: auto;
            color: white;
        }

        .toggle-btn {
            width: 30px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 0 10px 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin-top: auto;
            margin-bottom: auto;
            align-self: center;
            color: white;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        .toggle-btn:hover { background: rgba(255, 255, 255, 0.4); }

        /* 情緒條樣式 */
        .progress-bar-bg { background: rgba(255, 255, 255, 0.1); height: 8px; border-radius: 4px; overflow: hidden; }
        .progress-bar-fill { height: 100%; transition: width 0.3s ease; }

        /* 3D 畫布 */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* 啟動音訊按鈕 */
        #audio-start-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .neon-btn {
            background: transparent;
            border: 2px solid #00ffcc;
            color: #00ffcc;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 30px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }
        .neon-btn:hover {
            background: #00ffcc;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.8);
        }

        /* 音訊狀態指示器 */
        .audio-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            color: #00ffcc;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #00ffcc;
            z-index: 50;
        }
    </style>
</head>
<body>

    <!-- 3D 場景容器 -->
    <div id="canvas-container"></div>

    <!-- 啟動音訊的遮罩層 -->
    <div id="audio-start-overlay">
        <h1 class="text-4xl mb-8 font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">AI 3D 情緒粒子系統</h1>
        <p class="mb-8 text-gray-300 max-w-md text-center">請點擊下方按鈕以啟用音訊互動功能<br>系統將偵測 Max/MSP 的音樂輸出來驅動粒子特效</p>
        <button class="neon-btn" onclick="initApp()">進入體驗</button>
    </div>

    <!-- 音量監測指示 -->
    <div class="audio-indicator" id="audioStats">
        Audio Level: 0.00
    </div>

    <!-- 左側控制面板 -->
    <div class="control-panel-container" id="sidebarContainer">
        <div class="sidebar">
            <h2 class="text-2xl font-bold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-green-400">控制面板</h2>
            
            <div class="mb-6 space-y-4">
                <h3 class="text-lg font-semibold text-gray-300 border-b border-gray-700 pb-2">輸入來源</h3>
                
                <div class="flex gap-2">
                    <button onclick="setMode('upload')" id="btn-upload" class="flex-1 py-2 px-3 rounded bg-blue-600 text-sm hover:bg-blue-500 transition">上傳影片</button>
                    <button onclick="setMode('camera')" id="btn-camera" class="flex-1 py-2 px-3 rounded bg-gray-700 text-sm hover:bg-gray-600 transition">攝影機</button>
                </div>

                <div id="upload-section" class="space-y-2">
                    <input type="file" id="videoInput" accept="video/*" class="w-full text-xs text-gray-400 file:bg-gray-800 file:text-white file:border-0 file:rounded file:px-2 file:py-1">
                    <button onclick="uploadVideo()" class="w-full py-2 bg-green-700 rounded text-sm hover:bg-green-600 transition">確認上傳</button>
                </div>
            </div>

            <div class="mb-6">
                <button id="startBtn" onclick="toggleProcessing()" class="w-full py-3 bg-gradient-to-r from-purple-600 to-blue-600 rounded font-bold shadow-lg hover:shadow-purple-500/50 transition">
                    開始分析
                </button>
            </div>

            <div class="space-y-3">
                <h3 class="text-lg font-semibold text-gray-300 border-b border-gray-700 pb-2">情緒數據</h3>
                <div id="emotions-container">
                    <!-- 動態生成情緒條 -->
                </div>
            </div>

            <div class="mt-8 text-xs text-gray-500">
                <p>互動指南：</p>
                <ul class="list-disc pl-4 mt-1 space-y-1">
                    <li>左鍵拖曳：旋轉視角</li>
                    <li>滾輪滑動：縮放遠近</li>
                    <li>右鍵拖曳：平移視角</li>
                </ul>
            </div>
        </div>
        
        <div class="toggle-btn" onclick="toggleSidebar()">
            &lt;
        </div>
    </div>

    <!-- 隱藏的圖片元素，用於暫存 Socket 接收到的影像 -->
    <img id="texture-source" style="display:none;" crossorigin="anonymous">

    <!-- WebGL Shader: Vertex Shader (處理粒子位置與波動) -->
    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float uTime;
        uniform float uAudioLevel; // 音量大小
        uniform sampler2D uTexture; // 影像紋理
        
        attribute float size;
        attribute vec3 customColor;
        
        varying vec3 vColor;
        varying vec2 vUv;

        // 隨機函數
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        // 噪聲函數
        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        void main() {
            vUv = uv;
            
            // 讀取紋理顏色（翻轉 Y 軸以修正上下顛倒）
            vec4 texColor = texture2D(uTexture, vec2(uv.x, 1.0 - uv.y));
            
            // 計算亮度
            float brightness = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
            
            // 基礎位置
            vec3 pos = position;
            
            // 波動邏輯（僅在 Z 軸方向，保持 X/Y 位置穩定以維持視頻清晰度）：
            // 1. 基於時間的正弦波（速度隨音量增加）
            // 2. 基於音量的震幅 (uAudioLevel)
            // 3. 基於影像亮度的突起 (brightness)
            
            // 大幅降低頻率以減少波浪密度（畫面中更少的波浪）
            float waveFrequency = 0.001 + uAudioLevel * 0.0005; // 非常低的頻率 = 稀疏的波浪
            // 降低速度讓波浪移動更慢
            float waveSpeed = 0.2 + uAudioLevel * 0.3;
            
            // 單一主要波浪，更大更慢，密度更低
            float wave = sin(pos.x * waveFrequency + uTime * waveSpeed) * cos(pos.y * waveFrequency + uTime * waveSpeed * 0.8);
            
            // 音量驅動的 Z 軸位移（使用 noise 增加自然感，但降低強度）
            float audioDisplacement = uAudioLevel * 40.0 * noise(pos.xy * 0.08 + uTime * waveSpeed);
            float brightnessDisplacement = brightness * 10.0;
            
            // 只在 Z 軸方向位移
            pos.z += wave * (10.0 + uAudioLevel * 12.0) + audioDisplacement + brightnessDisplacement;

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            
            // 粒子大小隨著深度變化，並受音量影響變大
            gl_PointSize = (4.0 + uAudioLevel * 10.0 + brightness * 5.0) * (300.0 / -mvPosition.z);
            
            gl_Position = projectionMatrix * mvPosition;
            
            // 傳遞顏色給 Fragment Shader（使用原始顏色）
            vColor = texColor.rgb;
        }
    </script>

    <!-- WebGL Shader: Fragment Shader (處理粒子顏色) -->
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D uTexture;
        varying vec3 vColor;
        varying vec2 vUv;

        void main() {
            // 圓形粒子裁切
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;

            gl_FragColor = vec4(vColor, 1.0);
        }
    </script>

    <script>
        // --- 全域變數 ---
        const socket = io();
        let isProcessing = false;
        let inputMode = 'upload';
        let audioContext, analyser, dataArray;
        let scene, camera, renderer, particles, material;
        let particleTexture;
        let animationId;
        const width = 640; // 粒子網格寬度 (粒子數量 = width * height)
        const height = 360; // 粒子網格高度
        
        // 情緒定義
        const emotions = ['Happy', 'Angry', 'Sad', 'Surprise', 'Fear', 'Disgust', 'Neutral'];
        const emotionColors = {
            'Happy': '#FCD34D', 'Angry': '#EF4444', 'Sad': '#60A5FA', 
            'Surprise': '#A78BFA', 'Fear': '#4F46E5', 'Disgust': '#10B981', 'Neutral': '#9CA3AF'
        };

        // --- 初始化應用 ---
        function initApp() {
            document.getElementById('audio-start-overlay').style.display = 'none';
            initAudio(); // 初始化音訊監聽
            initThreeJS(); // 初始化 3D 場景
            initStats(); // 初始化 UI
            animate(); // 開始渲染迴圈
        }

        // --- 音訊處理 (監聽 Mic/System Audio) ---
        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256; // 頻譜大小
                
                // 獲取音訊輸入
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                console.log("Audio initialized successfully");
            } catch (err) {
                console.error("Audio init failed:", err);
                alert("無法取得麥克風權限，音訊互動功能將失效。請檢查瀏覽器權限。");
            }
        }

        function getAudioLevel() {
            if (!analyser) return 0;
            analyser.getByteFrequencyData(dataArray);
            
            // 計算平均音量 (0.0 ~ 1.0)
            let sum = 0;
            for(let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            let average = sum / dataArray.length;
            
            // 顯示數值
            document.getElementById('audioStats').innerText = `Audio Level: ${(average/255).toFixed(2)}`;
            
            // 稍微放大數值讓效果更明顯
            return Math.min((average / 255.0) * 2.0, 1.5);
        }

        // --- Three.js 3D 場景設定 ---
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            // 1. Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001); // 添加黑色霧氣增加深度感

            // 2. Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 120;
            camera.position.y = 20;

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 4. Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            // 允許完整 360 度旋轉，包括翻轉超過 180 度
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI;
            controls.enableRotate = true;
            window.controls = controls;

            // 5. Texture (初始黑色)
            const placeholderCanvas = document.createElement('canvas');
            placeholderCanvas.width = 480;
            placeholderCanvas.height = 360;
            const ctx = placeholderCanvas.getContext('2d');
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, 480, 360);
            ctx.fillStyle = '#333';
            ctx.font = '40px Arial';
            ctx.fillText('Waiting for Video...', 80, 180);
            
            particleTexture = new THREE.CanvasTexture(placeholderCanvas);

            // 6. Particles System
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const uvs = [];
            const indices = [];

            // 建立網格粒子
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const posX = (x - width / 2) * 1.0; // 間距 1.0 (保持合理密度)
                    const posY = (y - height / 2) * 1.0;
                    const posZ = 0;
                    
                    positions.push(posX, posY, posZ);
                    
                    // UV 座標 (用於對應 Texture)
                    // 注意：WebGL 的 UV Y 軸需要翻轉以匹配圖像座標系統
                    uvs.push(x / (width - 1), 1.0 - (y / (height - 1)));
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));

            // Shader Material
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0.0 },
                    uAudioLevel: { value: 0.0 },
                    uTexture: { value: particleTexture }
                },
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                transparent: true,
                depthTest: false,
                blending: THREE.AdditiveBlending // 發光效果
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 監聽視窗大小改變
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 渲染迴圈 ---
        function animate() {
            animationId = requestAnimationFrame(animate);

            const audioLevel = getAudioLevel();

            // 更新 Uniforms
            if (material) {
                material.uniforms.uTime.value += 0.05;
                // 平滑音量數值
                material.uniforms.uAudioLevel.value += (audioLevel - material.uniforms.uAudioLevel.value) * 0.1;
            }

            // 更新控制器
            if (window.controls) {
                // 如果正在分析且有音訊，根據音量稍微震動相機
                if (isProcessing && audioLevel > 0.5) {
                   camera.position.x += (Math.random() - 0.5) * 0.2;
                   camera.position.y += (Math.random() - 0.5) * 0.2;
                }
                window.controls.update();
            }

            renderer.render(scene, camera);
        }

        // --- Socket.io 邏輯 ---
        
        // 接收影像幀
        const imgSource = document.getElementById('texture-source');
        socket.on('video_frame', (data) => {
            if (!isProcessing) return;
            
            // 將 Base64 載入到隱藏的 img 標籤
            imgSource.src = `data:image/jpeg;base64,${data.image}`;
            
            // 當圖片載入完成，更新 Three.js Texture
            imgSource.onload = () => {
                if(particleTexture) {
                    particleTexture.image = imgSource;
                    particleTexture.needsUpdate = true;
                }
            };
        });

        // 簡單的相機復位函數
        function gsapCameraReset() {
            // 平滑移動相機到正面 (這裡簡單實作，也可以引入 GSAP)
            const targetPos = { x: 0, y: 0, z: 100 };
            const alpha = 0.05;
            camera.position.x += (targetPos.x - camera.position.x) * alpha;
            camera.position.y += (targetPos.y - camera.position.y) * alpha;
            camera.position.z += (targetPos.z - camera.position.z) * alpha;
        }

        // 接收情緒數據
        socket.on('emotion_update', (data) => {
            updateEmotionStats(data);
        });

        socket.on('processing_complete', (data) => {
            isProcessing = false;
            updateButtonState();
            alert(data.msg);
        });

        // --- UI 控制邏輯 ---

        function toggleProcessing() {
            if (isProcessing) {
                socket.emit('stop_processing');
                isProcessing = false;
                updateButtonState();
            } else {
                if (inputMode === 'upload' && !document.getElementById('videoInput').files.length && !hasUploaded) {
                    alert("請先上傳影片！");
                    return;
                }
                
                socket.emit('start_processing', { mode: inputMode });
                isProcessing = true;
                updateButtonState();
                
                // 播放音訊 Context (防呆)
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }
        }

        function setMode(mode) {
            if(isProcessing) return alert("請先停止分析");
            inputMode = mode;
            
            // UI 更新
            document.getElementById('btn-upload').className = mode === 'upload' 
                ? 'flex-1 py-2 px-3 rounded bg-blue-600 text-sm transition shadow-lg shadow-blue-500/50' 
                : 'flex-1 py-2 px-3 rounded bg-gray-700 text-sm hover:bg-gray-600 transition';
            
            document.getElementById('btn-camera').className = mode === 'camera' 
                ? 'flex-1 py-2 px-3 rounded bg-blue-600 text-sm transition shadow-lg shadow-blue-500/50' 
                : 'flex-1 py-2 px-3 rounded bg-gray-700 text-sm hover:bg-gray-600 transition';

            document.getElementById('upload-section').style.display = mode === 'upload' ? 'block' : 'none';
        }

        let hasUploaded = false;
        async function uploadVideo() {
            const file = document.getElementById('videoInput').files[0];
            if(!file) return alert("未選擇檔案");
            
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                const res = await fetch('/upload', { method: 'POST', body: formData });
                if(res.ok) {
                    alert("上傳成功！");
                    hasUploaded = true;
                }
            } catch(e) { console.error(e); alert("上傳失敗"); }
        }

        function updateButtonState() {
            const btn = document.getElementById('startBtn');
            if (isProcessing) {
                btn.innerText = "停止分析";
                btn.classList.replace('from-purple-600', 'from-red-600');
                btn.classList.replace('to-blue-600', 'to-red-500');
            } else {
                btn.innerText = "開始分析";
                btn.classList.replace('from-red-600', 'from-purple-600');
                btn.classList.replace('to-red-500', 'to-blue-600');
            }
        }

        function initStats() {
            const container = document.getElementById('emotions-container');
            container.innerHTML = '';
            emotions.forEach(emo => {
                container.innerHTML += `
                    <div>
                        <div class="flex justify-between text-xs text-gray-400 mb-1">
                            <span>${emo}</span>
                            <span id="val-${emo}">0%</span>
                        </div>
                        <div class="progress-bar-bg">
                            <div id="bar-${emo}" class="progress-bar-fill" style="width: 0%; background-color: ${emotionColors[emo]};"></div>
                        </div>
                    </div>
                `;
            });
        }

        function updateEmotionStats(data) {
            for (const [key, value] of Object.entries(data)) {
                const bar = document.getElementById(`bar-${key}`);
                const val = document.getElementById(`val-${key}`);
                if (bar && val) {
                    bar.style.width = `${value}%`;
                    val.innerText = `${value.toFixed(1)}%`;
                }
            }
        }

        // 側邊欄收合
        let isCollapsed = false;
        function toggleSidebar() {
            const container = document.getElementById('sidebarContainer');
            const btn = document.querySelector('.toggle-btn');
            isCollapsed = !isCollapsed;
            if(isCollapsed) {
                container.classList.add('collapsed');
                btn.innerHTML = '&gt;';
            } else {
                container.classList.remove('collapsed');
                btn.innerHTML = '&lt;';
            }
        }

        // 初始化
        setMode('upload');
    </script>
</body>
</html>